// [[Rcpp::plugins(cpp11)]]
#include <Rcpp.h>
#include <vector>

#include "Chromatid.hpp"
#include "Gamete.hpp"


Gamete::Gamete(){} // default-constructor

Gamete::Gamete(int allele, std::vector<double> L) // founder-constructor
{
  std::size_t n = L.size();
  std::vector<Chromatid> chromatids;
  chromatids.reserve(n);

  for (std::size_t k; k < n; ++k)
    {
      chromatids.push_back(Chromatid(allele, L[k]));
    }
  this->chromatids = chromatids;
}

Gamete::Gamete(std::vector<Chromatid> chromatids) // data-constructor
{
    std::size_t n  = chromatids.size();
    std::vector<Chromatid> chromatids_;
    chromatids_.reserve(n);
    for (std::size_t k; k < n; ++k)
    {
      const Chromatid& chromatid = chromatids[k];
      chromatids_.push_back(chromatid);
    }
    this->chromatids = chromatids_;
}

// This relies on the copy-constructor automatically generated by the compiler. Should work.
// Gamete::Gamete(std::vector<Chromatid> chromatids): chromatids(chromatids) {}


// // This assumes that the list is nested, only R types!
// Gamete::Gamete(Rcpp::List chromatids)
// {
//   std::size_t n  = chromatids.size();
//   std::vector<Chromatid> chromatids_;
//   chromatids_.reserve(n);
//   for (std::size_t k; k < n; ++k)
//   {
//     Rcpp::List chromatid = chromatids[k];
//     const t_alleles& alleles = Rcpp::as<t_alleles>(chromatid[0]);
//     const t_locations& locations = Rcpp::as<t_locations>(chromatid[1]);
//     chromatids_.push_back(Chromatid(alleles, locations));
//   }
//   this->chromatids = chromatids_;
// }


bool Gamete::operator==(const Gamete& other) const {return this == &other;}

std::size_t Gamete::length() const {return chromatids.size();}
void Gamete::append(const Chromatid& chromatid){chromatids.push_back(chromatid);}
